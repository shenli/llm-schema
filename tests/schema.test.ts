import { describe, expect, test } from 'vitest';
import {
  array,
  boolean,
  date,
  defineSchema,
  entity,
  enumType,
  md,
  number,
  text,
  type InferSchema,
  type SchemaValidationResult
} from '../src';

/*
Original Schema Definition (excerpt)
------------------------------------

defineSchema({
  title: text({ description: 'Meeting title', note: 'max 100 chars' }),
  summary: md({ optional: true, maxLength: 2000, note: 'markdown without h1 headings, max 2000 chars' }),
  actionItems: array({
    description: 'Action items with owners',
    schema: {
      task: text({ description: 'Specific and actionable task' }),
      owner: entity('person', { description: 'Contact ID or @handle' }),
      completed: boolean({ default: false })
    }
  }),
  priority: enumType(['high', 'medium', 'low'] as const, { optional: true, default: 'medium', note: 'pick the top priority level' }),
  durationMinutes: number({ min: 0, max: 480, optional: true, note: 'typically 15-120, range 0-480' }),
  scheduledFor: date({ optional: true, format: 'date', note: 'YYYY-MM-DD format' })
});

Converted Prompt Structure (excerpt)
-----------------------------------

Respond with JSON matching this schema:

{
  "title": string,                     // Meeting title, max 100 chars
  "summary"?: string,                  // Markdown without h1 headings, max 2000 chars
  "actionItems": [                     // Action items with owners, min 1 item
      {
        "task": string,                // Specific and actionable task
        "owner": string,               // Contact ID or @handle
        "completed"?: boolean
      }
    ],
  "priority"?: "high" | "medium" | "low", // pick the top priority level
  "durationMinutes"?: number,          // typically 15-120, range 0-480
  "scheduledFor"?: string              // YYYY-MM-DD format
}

Required fields: title, actionItems
*/

const MeetingNotesSchema = defineSchema({
  // Required meeting title used across summaries and UI cards.
  title: text({ description: 'Meeting title', note: 'max 100 chars' }),
  // Markdown summary generated by the LLM (optional, shown in detail views).
  summary: md({ optional: true, maxLength: 2000, note: 'markdown without h1 headings, max 2000 chars' }),
  // Structured list of action items the team should follow up on.
  actionItems: array({
    description: 'Action items with owners',
    minItems: 1,
    schema: {
      // Description of the specific task to complete.
      task: text({ description: 'Specific and actionable task' }),
      // Owner identifier for accountability (email, handle, etc.).
      owner: entity('person', { description: 'Contact ID or @handle' }),
      // Whether the action item has already been completed.
      completed: boolean({ default: false, optional: true })
    }
  }),
  // Priority level assigned by the LLM (defaults to medium).
  priority: enumType(['high', 'medium', 'low'] as const, { optional: true, default: 'medium', note: 'pick the top priority level' }),
  // Duration of the meeting in minutes (optional).
  durationMinutes: number({ min: 0, max: 480, optional: true, note: 'typically 15-120, range 0-480' }),
  // Scheduled date for the meeting (optional).
  scheduledFor: date({ optional: true, format: 'date', note: 'YYYY-MM-DD format' })
});

type MeetingNotes = InferSchema<typeof MeetingNotesSchema>;

describe('llm-schema core', () => {
  test('parses valid structured data', () => {
    const payload = {
      // Headline details captured by the LLM.
      title: 'Sprint Review',
      summary: 'Discussed **progress** and next steps.',
      actionItems: [
        // Open items should default to completed: false.
        { task: 'Prepare release notes', owner: 'alice' },
        { task: 'Update roadmap', owner: 'bob', completed: true }
      ],
      durationMinutes: 60
    } satisfies Partial<MeetingNotes>;

    const result = MeetingNotesSchema.safeParse(payload);

    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.priority).toBe('medium');
      expect(result.data.actionItems[0]).toEqual({
        task: 'Prepare release notes',
        owner: 'alice',
        completed: false
      });
    }
  });

  test('parse throws SchemaError when invalid', () => {
    const invalid = {
      summary: 123,
      actionItems: []
    } as unknown;

    const safe = MeetingNotesSchema.safeParse(invalid);
    expect(safe.success).toBe(false);

    expect(() => MeetingNotesSchema.parse(invalid)).toThrowError(/Failed to parse schema data/);
  });

  test('accepts JSON string input', () => {
    const payload = JSON.stringify({
      // Minimal payload with just the required fields.
      title: 'Weekly Sync',
      actionItems: [{ task: 'Send follow-up', owner: 'carol' }]
    });

    const parsed = MeetingNotesSchema.parse(payload);
    expect(parsed.actionItems).toHaveLength(1);
    expect(parsed.actionItems[0].completed).toBe(false);
  });

  test('toPrompt includes required fields, guidance, and structure without notes in JSON', () => {
    const prompt = MeetingNotesSchema.toPrompt({ format: 'detailed', includeExamples: false, includeConstraints: true });

    expect(prompt).toContain('Respond with JSON matching this schema:');
    expect(prompt).toContain('"title": string');
    expect(prompt).toContain('"summary"?: string');
    expect(prompt).toContain('"actionItems": [');
    expect(prompt).toContain('"task": string');
    expect(prompt).toContain('"owner": string');
    expect(prompt).toContain('"completed"?: boolean');
    expect(prompt).toContain('"priority"?: "high" | "medium" | "low"');
    expect(prompt).toContain('"durationMinutes"?: number');
    expect(prompt).toContain('// Action items with owners, min 1 item');
    expect(prompt).not.toContain('Optional.');
    expect(prompt).not.toContain('Note:');
    expect(prompt).toContain('Required fields: title, actionItems');
  });

  test('toPrompt omits guidance when includeConstraints is false', () => {
    const prompt = MeetingNotesSchema.toPrompt({ includeConstraints: false });
    expect(prompt).toContain('Respond with JSON matching this schema:');
  });

  test('toPrompt supports json structure style', () => {
    const prompt = MeetingNotesSchema.toPrompt({ structure: 'json' });
    expect(prompt).toContain('Return a JSON object matching this structure:');
    expect(prompt).toContain('"title": "<string>"');
    expect(prompt).toContain('"summary": "<string>"');
    expect(prompt).toContain('"actionItems": [');
    expect(prompt).toContain('"task": "<string>", // Specific and actionable task');
    expect(prompt).toContain('"owner": "<string>", // Contact ID or @handle');
    expect(prompt).toContain('"priority": "<high | medium | low>", // optional');
    expect(prompt).toContain('"durationMinutes": 0, // optional');
    expect(prompt).toContain('"scheduledFor": "<YYYY-MM-DD>"');
    expect(prompt).toContain('Required fields: title, actionItems');
  });

  test('exports JSON schema and tool schemas', () => {
    const jsonSchema = MeetingNotesSchema.toJsonSchema();
    expect(jsonSchema.type).toBe('object');
    expect(jsonSchema.properties?.title?.type).toBe('string');
    expect(jsonSchema.properties?.priority?.enum).toEqual(['high', 'medium', 'low']);

    const openAITool = MeetingNotesSchema.toOpenAITool({ name: 'capture_notes' });
    expect(openAITool.function.name).toBe('capture_notes');
    expect(openAITool.function.parameters.properties?.actionItems?.type).toBe('array');

    const anthropicTool = MeetingNotesSchema.toAnthropicTool({ name: 'meeting_tool' });
    expect(anthropicTool.name).toBe('meeting_tool');
    expect(anthropicTool.input_schema.type).toBe('object');
  });

  test('diff/search/entity utilities work with schema data', () => {
    const before = MeetingNotesSchema.parse({
      title: 'Sprint Review',
      actionItems: [{ task: 'Draft notes', owner: 'alice', completed: false }],
      priority: 'medium'
    });

    const after = MeetingNotesSchema.parse({
      title: 'Sprint Review v2',
      actionItems: [
        { task: 'Draft notes', owner: 'alice', completed: true },
        { task: 'Email summary', owner: 'bob', completed: false }
      ],
      priority: 'high'
    });

    const diff = MeetingNotesSchema.diff(before, after);
    expect(diff.changed.some((entry) => entry.path === 'priority')).toBe(true);
    expect(diff.added.some((entry) => entry.path === 'actionItems.1')).toBe(true);

    const merged = MeetingNotesSchema.merge(before, { priority: 'high' });
    expect(merged.priority).toBe('high');

    const search = MeetingNotesSchema.search(after, 'Email');
    expect(search.some((result) => result.path.includes('actionItems'))).toBe(true);

    const entities = MeetingNotesSchema.getEntities(after, 'person');
    expect(entities).toHaveLength(2);
  });
});
